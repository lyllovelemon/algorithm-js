## 二维数组的查找
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
```javascript
function Find(target,array) {
  for(let i=0,l=array.length;i<l;i++){
  	if(array[i].includes(target)){
  		return true;
  	}
  }
  return false;
}
```
## 替换空格
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
```javascript
    function replaceSpace(str) {
        str=str.replace(/\s+/g,'%20');
        return str;
	}
```
## 从尾到头打印链表
输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
```javascript
function printListFromTailToHead(head)
	{
		let arr=[]
        while (head){
			arr.unshift(head.val)
            head=head.next
        }
        return arr
		// write code here
	}
```
## 重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

### 思路
首先我们需要了解二叉树的遍历。
+ 前序遍历:根节点->左子树->右子树
+ 中序遍历:左子树->根节点->右子树
+ 后序遍历:左子树->右子树->根节点

[]()
```javascript
function reConstructBinaryTree(pre,vin) {
	//传入两个参数，分别代表前序遍历和中序遍历的序列
    //前序遍历序列长度为0->没有节点
	if(pre.length===0){
    	return null
    }
	//前序遍历长度为1->只有一个节点，即根节点
	if(pre.length===1){
		return new TreeNode(pre[0]);
    }
	const value=pre[0];//保存根节点的值
    const index=vin.indexOf(value);//寻找根节点在中序遍历的序号
    const vinLeft=vin.slice(0,index);//中序遍历的左子树
    const vinRight=vin.slice(index+1);//中序遍历的右子树
    const preLeft=pre.slice(1,index+1);//前序遍历的左子树
    const preRight=pre.slice(index+1);//前序遍历的右子树

    const node=new TreeNode(value);
    node.left=reConstructBinaryTree(preLeft,vinLeft);
    node.right=reConstructBinaryTree(preRight,vinRight);
    return node;
}
```
## 二叉树的前序遍历
递归实现
```javascript
var preorderTravalsal=function(root,array=[]) {
  if(root){
  	array.push(root.val);
  	preorderTravalsal(root.left,array);
  	preorderTravalsal(root.right,array);
  }
  return array;
}
```
## 二叉树的中序遍历
递归实现
```javascript
var inOrderTravalsal=function(root,array=[]) {
  if(root){
  	inOrderTravalsal(root.left,array)
  	array.push(root.val);
  	inOrderTravalsal(root.right,array)
  }
  return array
}
```
## 二叉树的后序遍历
```javascript
var postorderTraversa=function(root,array=[]) {
  if(root){
  	postorderTraversa(root.left,array);
  	postorderTraversa(root.right,array);
  	array.push(root.val)
  }
  return array
}
```
## 用两个栈实现队列
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
```javascript
const stack1=[];//栈1用于入队列存储
const  stack2=[];//栈2用于出队列存储
    function push(node) {
        stack1.push(node)
	}
	function pop() {
        if(!stack2.length){
        	while (stack1.length>0){
        		stack2.push(stack1.pop())
            } 
        }
        return stack2.pop()||null;
	}
```
## 旋转数组的最小数字
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
```javascript
function minNumberInRotateArray(rotateArray)
	{
		if(rotateArray.length===0){
			return 0;
        }
		let arr=rotateArray.toString().split(',');
         return Math.min(...arr)

	}
```
+ 考察点：二分查找

## 斐波那契数列
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39
```javascript
    var cache={
    	0:0,
        1:1
    };
	function Fibonacci(n)
	{
		// write code here
		return typeof cache[n]==='number'?cache[n]:cache[n]=Fibonacci(n-1)+Fibonacci(n-2);
	}
```
## 跳台阶
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
牺牲空间解法:
```javascript
function jumpFloor(number)
	{
		// write code here
		if(number===0){ return 0}
		if(number===1){return 1}
		if(number===2){console.log(2)}
		if(number>2){
			let record=[];
			record[1]=1;
            record[2]=2;
            for(let i=3;i<=number;i++){
            	record[i]=record[i-1]+record[i-2]
            }
            return record[number]
        }
	}
```
## 变态跳台阶
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
```javascript
  function jumpFloorII(number)
    {
        // write code here

      return 1<<(--number)


    }

```
## 数值的整数次方
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
保证base和exponent不同时为0
```javascript
function Power(base, exponent)
{
	var res=1,curr=base,n;
	if(exponent>0){
		n=exponent
	}
	else if(exponent<0){
		if(base===0){
			throw new Error('分母不能为0')
		}
		n=-exponent;
	}
	else {
		return 1;
	}
    while (n!==0){
		if((n&1)==1){
			res*=curr;
		}
		curr*=curr;
		n>>=1
    } 
	return exponent>=0?res:(1/res);
}
```
## 调整数组顺序使奇数位于偶数前面
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，
并保证奇数和奇数，偶数和偶数之间的相对位置不变。
```javascript
function reOrderArray(array)
{
    // write code here
    let double=array.filter(item=>{
    	return item%2===0
    })
    let ji=array.filter(item=>{
    	return item%2!==0
    })
    let newArr=ji.concat(double)
    return newArr
    
}
```
### 链表中倒数第k个结点
输入一个链表，输出该链表中倒数第k个结点。
```javascript
function FindKthToTail(head, k)
{
    let arr=[]
    while (head!==null){
    	arr.push(head);
    	head=head.next
    } 
    return arr[arr.length-k];
}
```
## 反转链表
输入一个链表，反转链表后，输出新链表的表头。
```javascript
function ReverseList(pHead)
{
    // write code here
    let node=pHead,arr=[];
    while(node!==null){
    	arr.push(node.val);
    	node=node.next;
    }
   node=pHead;
    while (node!==null){
    	node.val=arr.pop();
    	node=node.next
    } 
    return pHead;
}
```
## 合并两个排序的链表
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
```javascript
function Merge(pHead1, pHead2)
{
    // write code here
    let list={};
    if(pHead1===null){
    	list=pHead2;
    }
    else if(pHead2===null){
    	list=pHead1;
    }
    else {
    	if(pHead1.val<pHead2.val){
    		list=pHead1;
    		list.next=Merge(pHead1.next,pHead2)
    	}
    	else {
    		list=pHead2;
    		list.next=Merge(pHead1,pHead2.next)
    	}
    }
    return list
   
}
```
## 树的子结构
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
```javascript
function isSubtree(root1, root2) {
    if (root2 == null) return true;
    if (root1 == null) return false;
    if (root1.val == root2.val) {
        return isSubtree(root1.left, root2.left) &&
            isSubtree(root1.right, root2.right);
    } else {
        return false;   
    }
}
 
function HasSubtree(pRoot1, pRoot2)
{
   if (pRoot1 == null || pRoot2 == null) {
       return false;
   }
    return isSubtree(pRoot1, pRoot2) ||
        HasSubtree(pRoot1.left, pRoot2) ||
        HasSubtree(pRoot1.right, pRoot2);
}
```
## 二叉树的镜像
操作给定的二叉树，将其变换为源二叉树的镜像。
思路：递归交换左右子树
```javascript
function Mirror(root)
{
    // write code here
  if(root){
  	let temp=root.left;
  	root.left=root.right;
  	root.right=temp;
  	Mirror(root.left);
  	Mirror(root.right);
  }
}
```
## 包含min函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
```javascript
let stack=[];
function push(node)
{
    // write code here
    stack.push(node)
}
function pop()
{
    // write code here
    return stack.length===0?null:stack.pop();
}
function top()
{
    // write code here
    return stack.length===0?null:stack[0];
}
function min()
{
    // write code here
    return Math.min.apply(this,stack);
}
```
## 栈的压入、弹出序列
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
```javascript
function IsPopOrder(pushV, popV)
{
    // write code here
    let stack=[],idx=0;
    if(!pushV||pushV.length===0||!popV||popV.length===0){
    	return;
    }
   for(let i=0;i<pushV.length;i++){
   	stack.push(pushV[i]);
   	while (stack.length&&stack[stack.length-1]===popV[idx]){
   		stack.pop();
   		idx++
   	} 
   }
   return stack.length==0
    
}
```
## 从上往下打印二叉树
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
```javascript
function PrintFromTopToBottom(root)
{
    // write code here
    let arr=[],data=[]
   if(root){
   	arr.push(root)
   }
   while (arr.length){
   	var node=arr.shift();
   	if(node.left){
   		arr.push(node.left)
   	}
   	if(node.right){
   		arr.push(node.right)
   	}
   	data.push(node.val)
   } 
   return data;
}
```
## 二叉搜索树的后序遍历序列
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

思路:
1.根据后序遍历序列可以得到根节点,左子树的值比根节点小，右子树的值比根节点大，由此分为三部分
2. 右节点的值比根节点小，则返回false
3. 左右子树若存在，递归遍历左右子树是否符合规范
```javascript
//todo
function VerifySquenceOfBST(sequence)
{
    // write code here
    if(!sequence.length) return false;
    return adjustSequence(sequence,0,sequence.length-1);
    //最后一个节点为根节点  
  
}
function adjustSequence(sequence,start,end){
	if(start>=end) return true;
	var i=start;
	while (i<end && sequence[i]<sequence[end]){
		i++
	} 
	for(var j=i;j<end;j++){
		if(sequence[j]<sequence[end]){
			return false;
		}
	}
	return adjustSequence(sequence,start,i-1)&&adjustSequence(sequence.i,end-1);
}
```
## 二叉树中和为某一值的路径
输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

思路:
叶节点:既没有左节点又没有右节点的节点叫叶子节点.(node.left===null && node.right=null)

1. 首先定义存放路径和节点值和的变量
```javascript
function FindPath(root, expectNumber)
{
    // write code here
 var result=[];
 if(root===null){
 	return result;
 }
    dfsFind(root,expectNumber,[],0,result);
    return result;
}
function dfsFind(root,expectNumber,path,currentSum,result) {
  currentSum+=root.val;
  path.push(root.val);
  const isLeaf=root.left===null&& root.right===null;//叶子节点
  if(isLeaf && currentSum===expectNumber){
  	result.push(path.slice(0))
  }
  if(root.left!==null){
  	dfsFind(root.left,expectNumber,path,currentSum,result)
  }
  if(root.right!==null){
  	dfsFind(root.right,expectNumber,path,currentSum,result)
  }
  path.pop();
}
```
## 复杂链表的复制
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
```javascript
function RandomListNode(x){
    this.label = x;
    this.next = null;
    this.random = null;
}
function Clone(pHead)
{
    // write code here
    if(pHead==null) return null;
    let head=new RandomListNode(pHead.label);
    head.random=pHead.random;
    head.next=Clone(pHead.next);
    return head;
    
}
```
## 二叉搜索树和双向链表
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
```javascript
function Convert(pRootOfTree)
{
    // write code here
    if(!pRootOfTree){
        return null;
    }
    var arr=[],len=0;
    sub(pRootOfTree,arr);
    len=arr.length;
    arr[0].left=null;
    arr[0].right=arr[1];
    for(var i=1;i<len-1;i++){
        arr[i].left=arr[i-1];
        arr[i].right=arr[i+1];
    }
    arr[len-1].left=arr[len-2]
    arr[len-1].right=null;
    return arr[0];
}
function sub(node,arr){
    if(!node){
        return null;
    }
    sub(node.left,arr);
    arr.push(node);
    sub(node.right,arr);
}
```
## 数组中出现次数超过一半的数字
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
```javascript
function MoreThanHalfNum_Solution(numbers)
{
 	// write code here
         let len=numbers.length;//定义数组的长度
 		if(len===0) {
 			return 0;
         }
 		var num=numbers[0],count=1;//num-从数组第一个值开始遍历，count-重复数字出现的次数
 		for(var i=0;i<len;i++){
 			if(num===numbers[i]){
 				count++;
             }
 			else {
 				count--;
             }
 			if(count===0){
 				num=numbers[i];
 				count=1;
             }
         }
 		count=0;
 		for(var i=0;i<len;i++){
 			if(numbers[i]===num)count++;
         }
 		if(count*2>len) return num;
 		return 0;
}
```
## 最小的k个数
```javascript

```