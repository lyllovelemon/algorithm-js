## 二维数组的查找
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
```javascript
function Find(target,array) {
  for(let i=0,l=array.length;i<l;i++){
  	if(array[i].includes(target)){
  		return true;
  	}
  }
  return false;
}
```
## 替换空格
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
```javascript
    function replaceSpace(str) {
        str=str.replace(/\s+/g,'%20');
        return str;
	}
```
## 从尾到头打印链表
输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
```javascript
function printListFromTailToHead(head)
	{
		let arr=[]
        while (head){
			arr.unshift(head.val)
            head=head.next
        }
        return arr
		// write code here
	}
```
## 重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

### 思路
首先我们需要了解二叉树的遍历。
+ 前序遍历:根节点->左子树->右子树
+ 中序遍历:左子树->根节点->右子树
+ 后序遍历:左子树->右子树->根节点

[]()
```javascript
function reConstructBinaryTree(pre,vin) {
	//传入两个参数，分别代表前序遍历和中序遍历的序列
    //前序遍历序列长度为0->没有节点
	if(pre.length===0){
    	return null
    }
	//前序遍历长度为1->只有一个节点，即根节点
	if(pre.length===1){
		return new TreeNode(pre[0]);
    }
	const value=pre[0];//保存根节点的值
    const index=vin.indexOf(value);//寻找根节点在中序遍历的序号
    const vinLeft=vin.slice(0,index);//中序遍历的左子树
    const vinRight=vin.slice(index+1);//中序遍历的右子树
    const preLeft=pre.slice(1,index+1);//前序遍历的左子树
    const preRight=pre.slice(index+1);//前序遍历的右子树

    const node=new TreeNode(value);
    node.left=reConstructBinaryTree(preLeft,vinLeft);
    node.right=reConstructBinaryTree(preRight,vinRight);
    return node;
}
```
## 二叉树的前序遍历
递归实现
```javascript
var preorderTravalsal=function(root,array=[]) {
  if(root){
  	array.push(root.val);
  	preorderTravalsal(root.left,array);
  	preorderTravalsal(root.right,array);
  }
  return array;
}
```
## 二叉树的中序遍历
递归实现
```javascript
var inOrderTravalsal=function(root,array=[]) {
  if(root){
  	inOrderTravalsal(root.left,array)
  	array.push(root.val);
  	inOrderTravalsal(root.right,array)
  }
  return array
}
```
## 二叉树的后序遍历
```javascript
var postorderTraversa=function(root,array=[]) {
  if(root){
  	postorderTraversa(root.left,array);
  	postorderTraversa(root.right,array);
  	array.push(root.val)
  }
  return array
}
```
## 用两个栈实现队列
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
```javascript
const stack1=[];//栈1用于入队列存储
const  stack2=[];//栈2用于出队列存储
    function push(node) {
        stack1.push(node)
	}
	function pop() {
        if(!stack2.length){
        	while (stack1.length>0){
        		stack2.push(stack1.pop())
            } 
        }
        return stack2.pop()||null;
	}
```
## 旋转数组的最小数字
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
```javascript
function minNumberInRotateArray(rotateArray)
	{
		if(rotateArray.length===0){
			return 0;
        }
		let arr=rotateArray.toString().split(',');
         return Math.min(...arr)

	}
```
+ 考察点：二分查找

## 斐波那契数列
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39
```javascript
    var cache={
    	0:0,
        1:1
    };
	function Fibonacci(n)
	{
		// write code here
		return typeof cache[n]==='number'?cache[n]:cache[n]=Fibonacci(n-1)+Fibonacci(n-2);
	}
```
## 跳台阶
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
牺牲空间解法:
```javascript
function jumpFloor(number)
	{
		// write code here
		if(number===0){ return 0}
		if(number===1){return 1}
		if(number===2){console.log(2)}
		if(number>2){
			let record=[];
			record[1]=1;
            record[2]=2;
            for(let i=3;i<=number;i++){
            	record[i]=record[i-1]+record[i-2]
            }
            return record[number]
        }
	}
```
## 变态跳台阶
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
```javascript
  function jumpFloorII(number)
    {
        // write code here

      return 1<<(--number)


    }

```
## 数值的整数次方
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
保证base和exponent不同时为0
```javascript
function Power(base, exponent)
{
	var res=1,curr=base,n;
	if(exponent>0){
		n=exponent
	}
	else if(exponent<0){
		if(base===0){
			throw new Error('分母不能为0')
		}
		n=-exponent;
	}
	else {
		return 1;
	}
    while (n!==0){
		if((n&1)==1){
			res*=curr;
		}
		curr*=curr;
		n>>=1
    } 
	return exponent>=0?res:(1/res);
}
```
## 调整数组顺序使奇数位于偶数前面
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，
并保证奇数和奇数，偶数和偶数之间的相对位置不变。
```javascript
function reOrderArray(array)
{
    // write code here
    let double=array.filter(item=>{
    	return item%2===0
    })
    let ji=array.filter(item=>{
    	return item%2!==0
    })
    let newArr=ji.concat(double)
    return newArr
    
}
```
### 链表中倒数第k个结点
输入一个链表，输出该链表中倒数第k个结点。
```javascript
function FindKthToTail(head, k)
{
    let arr=[]
    while (head!==null){
    	arr.push(head);
    	head=head.next
    } 
    return arr[arr.length-k];
}
```
## 反转链表
输入一个链表，反转链表后，输出新链表的表头。
```javascript
function ReverseList(pHead)
{
    // write code here
    let node=pHead,arr=[];
    while(node!==null){
    	arr.push(node.val);
    	node=node.next;
    }
   node=pHead;
    while (node!==null){
    	node.val=arr.pop();
    	node=node.next
    } 
    return pHead;
}
```
## 合并两个排序的链表
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
```javascript
function Merge(pHead1, pHead2)
{
    // write code here
    let list={};
    if(pHead1===null){
    	list=pHead2;
    }
    else if(pHead2===null){
    	list=pHead1;
    }
    else {
    	if(pHead1.val<pHead2.val){
    		list=pHead1;
    		list.next=Merge(pHead1.next,pHead2)
    	}
    	else {
    		list=pHead2;
    		list.next=Merge(pHead1,pHead2.next)
    	}
    }
    return list
   
}
```
## 树的子结构
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
```javascript
function isSubtree(root1, root2) {
    if (root2 == null) return true;
    if (root1 == null) return false;
    if (root1.val == root2.val) {
        return isSubtree(root1.left, root2.left) &&
            isSubtree(root1.right, root2.right);
    } else {
        return false;   
    }
}
 
function HasSubtree(pRoot1, pRoot2)
{
   if (pRoot1 == null || pRoot2 == null) {
       return false;
   }
    return isSubtree(pRoot1, pRoot2) ||
        HasSubtree(pRoot1.left, pRoot2) ||
        HasSubtree(pRoot1.right, pRoot2);
}
```
## 二叉树的镜像
操作给定的二叉树，将其变换为源二叉树的镜像。
思路：递归交换左右子树
```javascript
function Mirror(root)
{
    // write code here
  if(root){
  	let temp=root.left;
  	root.left=root.right;
  	root.right=temp;
  	Mirror(root.left);
  	Mirror(root.right);
  }
}
```
## 包含min函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
```javascript
let stack=[];
function push(node)
{
    // write code here
    stack.push(node)
}
function pop()
{
    // write code here
    return stack.length===0?null:stack.pop();
}
function top()
{
    // write code here
    return stack.length===0?null:stack[0];
}
function min()
{
    // write code here
    return Math.min.apply(this,stack);
}
```
## 栈的压入、弹出序列
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
```javascript
function IsPopOrder(pushV, popV)
{
    // write code here
    let stack=[],idx=0;
    if(!pushV||pushV.length===0||!popV||popV.length===0){
    	return;
    }
   for(let i=0;i<pushV.length;i++){
   	stack.push(pushV[i]);
   	while (stack.length&&stack[stack.length-1]===popV[idx]){
   		stack.pop();
   		idx++
   	} 
   }
   return stack.length==0
    
}
```
## 从上往下打印二叉树
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
```javascript
function PrintFromTopToBottom(root)
{
    // write code here
    let arr=[],data=[]
   if(root){
   	arr.push(root)
   }
   while (arr.length){
   	var node=arr.shift();
   	if(node.left){
   		arr.push(node.left)
   	}
   	if(node.right){
   		arr.push(node.right)
   	}
   	data.push(node.val)
   } 
   return data;
}
```
## 二叉搜索树的后序遍历序列
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

思路:
1.根据后序遍历序列可以得到根节点,左子树的值比根节点小，右子树的值比根节点大，由此分为三部分
2. 右节点的值比根节点小，则返回false
3. 左右子树若存在，递归遍历左右子树是否符合规范
```javascript
//todo
function VerifySquenceOfBST(sequence)
{
    // write code here
    if(!sequence.length) return false;
    return adjustSequence(sequence,0,sequence.length-1);
    //最后一个节点为根节点  
  
}
function adjustSequence(sequence,start,end){
	if(start>=end) return true;
	var i=start;
	while (i<end && sequence[i]<sequence[end]){
		i++
	} 
	for(var j=i;j<end;j++){
		if(sequence[j]<sequence[end]){
			return false;
		}
	}
	return adjustSequence(sequence,start,i-1)&&adjustSequence(sequence.i,end-1);
}
```
## 二叉树中和为某一值的路径
输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

思路:
叶节点:既没有左节点又没有右节点的节点叫叶子节点.(node.left===null && node.right=null)

1. 首先定义存放路径和节点值和的变量
```javascript
function FindPath(root, expectNumber)
{
    // write code here
 var result=[];
 if(root===null){
 	return result;
 }
    dfsFind(root,expectNumber,[],0,result);
    return result;
}
function dfsFind(root,expectNumber,path,currentSum,result) {
  currentSum+=root.val;
  path.push(root.val);
  const isLeaf=root.left===null&& root.right===null;//叶子节点
  if(isLeaf && currentSum===expectNumber){
  	result.push(path.slice(0))
  }
  if(root.left!==null){
  	dfsFind(root.left,expectNumber,path,currentSum,result)
  }
  if(root.right!==null){
  	dfsFind(root.right,expectNumber,path,currentSum,result)
  }
  path.pop();
}
```
## 复杂链表的复制
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
```javascript
function RandomListNode(x){
    this.label = x;
    this.next = null;
    this.random = null;
}
function Clone(pHead)
{
    // write code here
    if(pHead==null) return null;
    let head=new RandomListNode(pHead.label);
    head.random=pHead.random;
    head.next=Clone(pHead.next);
    return head;
    
}
```
## 二叉搜索树和双向链表
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
```javascript
function Convert(pRootOfTree)
{
    // write code here
    if(!pRootOfTree){
        return null;
    }
    var arr=[],len=0;
    sub(pRootOfTree,arr);
    len=arr.length;
    arr[0].left=null;
    arr[0].right=arr[1];
    for(var i=1;i<len-1;i++){
        arr[i].left=arr[i-1];
        arr[i].right=arr[i+1];
    }
    arr[len-1].left=arr[len-2]
    arr[len-1].right=null;
    return arr[0];
}
function sub(node,arr){
    if(!node){
        return null;
    }
    sub(node.left,arr);
    arr.push(node);
    sub(node.right,arr);
}
```
## 数组中出现次数超过一半的数字
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
```javascript
function MoreThanHalfNum_Solution(numbers)
{
 	// write code here
         let len=numbers.length;//定义数组的长度
 		if(len===0) {
 			return 0;
         }
 		var num=numbers[0],count=1;//num-从数组第一个值开始遍历，count-重复数字出现的次数
 		for(var i=0;i<len;i++){
 			if(num===numbers[i]){
 				count++;
             }
 			else {
 				count--;
             }
 			if(count===0){
 				num=numbers[i];
 				count=1;
             }
         }
 		count=0;
 		for(var i=0;i<len;i++){
 			if(numbers[i]===num)count++;
         }
 		if(count*2>len) return num;
 		return 0;
}
```
## 最小的k个数
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
```javascript
function GetLeastNumbers_Solution(input, k)
{
    // write code here
       let result=input.sort((a,b)=>{
           	return a-b;
       });
       return result.length>=k?result.slice(0,k):[];
}
```
## 连续子数组的最大和
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
```javascript
        let ans=array[0],sum=0;
        for(const num of array){
        	if(sum>0){
        		sum+=num
            }
        	else {
        		sum=num
            }
        	ans=Math.max(ans,sum);
        }
        return ans;
```
> 考察点:动态规划
## 链表中环的入口结点
给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

思路:
1. 首先需要知道链表中有环的条件:如果链表中有重复的节点（该节点被遍历过两次），则该链表有环。
2. 依次遍历链表中的节点，每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点。用新节点id与
此节点以前的所有节点的id进行比较，两者相等则有环。否则继续遍历下一个节点，重复上面的步骤。

```javascript
function EntryNodeOfLoop(pHead)
{
    // write code here
    let arr=[]
    while (pHead){
    	arr.push(pHead.val)
    	pHead=pHead.next
    } 
    return null;
}
```
## 把数组排成最小的数
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
```javascript
	function PrintMinNumber(numbers)
	{
		// write code here
		if(numbers.length===0){
			return '';
		}
		else if(numbers.length===1){
			return numbers[0]
        }
		let sorted=numbers.sort((a,b)=>{
			let aStr=a.toString(),bStr=b.toString();
			let result1=aStr+bStr,result2=bStr+aStr;
			return result1-result2;
        });
		let res='';
		for(let i=0;i<sorted.length;i++){
			res+=sorted[i]
        }
		return +res;

	}
```
## 丑数
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

思路：
1.把所有丑数保存在数组里，返回第index个数组
2. 第一个丑数是1，把它存入丑数数组
3. 第二个丑数是index*2,index*3,index*5三者的最小值，将其存入丑数
4. 依次循环遍历
```javascript
function GetUglyNumber_Solution(index)
	{
		if(index<=0) return 0;

		let arr=[1];
		let factor2=0,factor3=0,factor5=0;
		for(let i=1;i<index;i++){
			arr[i]=Math.min(arr[factor2]*2,arr[factor3]*3,arr[factor5]*5);
			if(arr[i]===arr[factor2]*2){factor2++}
			if(arr[i]===arr[factor3]*3){factor3++}
			if(arr[i]===arr[factor5]*5){factor5++}
        }
		return arr[index-1];
		// write code here
	}
```
## 第一个只出现一次的字符
在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.
```javascript
function FirstNotRepeatingChar(str)
{
    // write code here
    var length=str.length;
    for(var i=0;i<length;i++)
    {
       if(str.lastIndexOf(str[i])==str.indexOf(str[i]))
       {
           return i;
           break;
       }
 
    }
     
    return -1;
}
```
## 数组中的逆序对
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
```javascript

```
## 两个链表的第一个公共结点
输入两个链表，找出它们的第一个公共结点。
```javascript
function FindFirstCommonNode(pHead1, pHead2)
{
    // write code here
    var p1 = pHead1;
    var p2 = pHead2;
    while(p1 != p2){
        p1 = (p1 == null ? pHead2 : p1.next);
        p2 = (p2 == null ? pHead1 : p2.next);
    }
    return p1;
}
```
## 数字在排序数组中出现的次数
统计一个数字在排序数组中出现的次数。
```javascript
function GetNumberOfK(data, k)
{
    // write code here
    let count=0;
    if(!data){
    	return 0;
    }
    for(let i=0;i<data.length;i++){
    	if(data[i]===k){
    		count++;
    	}
    }
    return count;
    
}
```
## 二叉树的深度
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
```javascript
function TreeDepth(pRoot)
{
    // write code here
    if(!pRoot){
    	return 0;
    }
    var left=1+TreeDepth(pRoot.left);
    var right=1+TreeDepth(pRoot.right);
    let depth=Math.max(left,right);
    return depth;
}
```
## 平衡二叉树
输入一棵二叉树，判断该二叉树是否是平衡二叉树。

平衡二叉树(AVL树):
任一节点对应的两棵子树的最大高度差为1.（即左右子树的高度相差不超过1）
+ 可以是空树
+ 假如不是空树，任何一个结点的左子树和右子树都是平衡二叉树，且高度之差的绝对值不超过1.

```javascript
var isBalanced = true;
function IsBalanced_Solution(pRoot){
    if(pRoot == null){
        return true;
    }
    IsBalanced(pRoot);
    var result = isBalanced;
    isBalanced = true;
    return result;
}
function IsBalanced(pRoot){
    if(pRoot == null){
        return 0;
    }
    var left = 0,
        right = 0;
    if(pRoot.left){
        left = IsBalanced(pRoot.left);
    }
    if(pRoot.right){
        right = IsBalanced(pRoot.right);
    }
    if(Math.abs(left - right) > 1){
        isBalanced = false;
    }
    return left > right ? left + 1 : right + 1;
}

```
## 数组中只出现一次的数字
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
```javascript
function FindNumsAppearOnce(array)
{
	
    // write code here
    // return list, 比如[a,b]，其中ab是出现一次的两个数字
    var arr=[];
    for(let i=0;i<array.length;i++){
    	if(array.indexOf(array[i])===array.lastIndexOf(array[i])){
    		arr.push(array[i])
    	}
    }
      return arr;
}
```