## 考点：原型链
```ecmascript 6
Object.prototype.a='Object';
Function.prototype.a='Function';
function Person() {}
var child=new Person();
console.log(Person.a);
console.log(child.a);
console.log(Person.constructor);
console.log(child.constructor);
console.log(child._proto_);
console.log(child._proto_._proto_);
console.log(child._proto_._proto_.constructor);
console.log(child._proto_._proto_.constructor.constructor);
console.log(child._proto_._proto_.constructor.constructor.constructor);
```
解法:
+ 构造函数和对象，都是对象。只要是对象，就有constructor和_proto_两个属性。

'.constructor':谁new的我，我就指向谁

'._proto_':谁new的我，我就指向它的prototype
1. 第一个console语句，Person是个函数，本身没有a属性，我们从它的原型链寻找，即Person._proto_
,Person是函数new的，因此指向Function.prototype,它存在a属性'Function'，因此输出'Function'

2. 第二个console语句,child是Person new出来的对象，本身没有a属性，根据原型链查找规则会寻找child._proto_,
即Object.prototype是否存在a属性，找到值为'Object',因此输出Object

3. 第三个console语句，寻找Person的constructor,Person是个Function,已知Function的constructor(构造函数)仍然是Function.
4. 第四个console语句，根据'.constructor':谁new的我，我就指向谁的规则，child是Person new出来的，因此指向Person，Person是个Function，
因此返回值为Person(){}
+ Function可看作自己new自己，因此'Function.constructor'指向的是Function，'Function._proto_'指的也是自己的prototype.

+ Function new 出来的'Function.prototype'是个函数，而其他构造函数new出来的都是对象。
+ Object.prototype._proto_指向的是null

5. 第五个console语句，指向Person.prototype，即Person(){}
6. Object.prototype，即Object(){}
7. Object()
8. Function(){}
9. Function(){}

## 考点:闭包
实现一个foo函数，返回自身调用次数
```ecmascript 6
a=foo();
b=foo();
c=foo();//此时a===1,b===2,c===3

foo.reset();
d=foo();//d===1
```
实现思路:闭包,注意i变量必须使用var声明，确保在reset函数里拿到的i和helper中的i是一样的。
```ecmascript 6
var helper=function(){
	var i=0;
	return function () {
		return ++i;
	}
}
var foo=helper();
Function.prototype.reset=function () {
	return i=0
}
a=foo();
b=foo();
c=foo();
foo.reset();
d=foo();
```