# Event-loop运行机制

## js为什么是单线程？

Javascript是运行在浏览器的语言，js的单线程与它的用途有关。作为浏览器脚本语言，它的用途主要是与用户互动。
以DOM操作为例，如果同时有两个线程：一个是在DOM上增加节点，一个是在DOM上删除节点，浏览器应该以哪个线程为准。
由此，js的单线程保证了DOM操作的一致性。

## 任务队列
单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

1.所有同步任务都在一个执行栈上执行。
2.执行栈之外，还有一个任务队列，用于存放异步任务。
3.一旦执行栈所有同步任务执行完毕，依次读取任务队列的异步任务，压入执行栈
4.主线程不断重复以上三步
主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

## 宏任务和微任务
就像去银行办理业务一样，先要取号进行排队。柜员同时只能处理一个客户的业务。每一个办理业务的人可以当作宏任务
看待。当柜员处理完当前客户的业务，广播下一位就是下一个宏任务的开始。

在宏任务的执行过程中，可以添加一些微任务。就像在前台办理业务，你前面的大爷可能在存款，在存款业务办理完后，
可能会办理一些其他的业务，比如信贷，理财，信用卡。这些都可以当作微任务。

当前的微任务没有执行完时，下一个宏任务是不会执行的。

```javascript
setTimeout(()=>{
	console.log('a')
})
new Promise(resolve => {
	resolve();
	console.log('b');
}).then(()=>{
	console.log('c');
})
console.log('d');
```
执行顺序是怎样的?

> setTimeout是作为宏任务来存在的，而promise.then则是具有代表性的微任务。

在promise/A+的规范中，[promise]()的实现可以是微任务，也可以是宏任务。但是普遍的
共识，promise属于微任务。

## 宏任务
+ I/O
+ setTimeout
+ setInterval
+ setImmediate
+ requestAnimationFrame
有些地方会列出来UI rendering作为宏任务，但是HTML规范文档把它列为跟微任务平行的一个操作步骤。

## 微任务
+ process.nextTick
+ MutationObserver
+ promise.then catch finally
+ await

## 答案
1.
 ```javascript
//b
//d
//c
//a
```