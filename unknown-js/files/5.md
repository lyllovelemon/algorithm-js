# this词法
ES6添加了一个特殊的语法形式用于函数声明，叫箭头函数。
```javascript
var foo=a=>{
	console.log(a);
};
foo(2);//2
```
箭头函数的写法通常被当作function关键字的简写。
```javascript
var obj={
	id:'awesome',
	cool:function coolFn() {
	  console.log(this.id);
	}
};
var id="not awesome"
obj.cool();
setTimeout(obj.cool,100)
```
问题在于cool()函数丢失了同this之间的绑定，解决这个问题有很多办法。
比如var self=this;

```javascript
var obj={
	count:0,
	cool:function coolFn() {
	  var self=this;
	  if(self.count<1){
	  	setTimeout(function timer() {
	  	  self.count++;
	  	  console.log('awesome?');
	  	},100)
	  }
	}
}
obj.cool();
```
self是一个通过词法作用域和闭包进行引用的操作符，不关心this绑定的时候发生了什么。
箭头函数在涉及this绑定时的行为和普通函数的行为完全不一致。它放弃了
this绑定的规则，用当前词法作用域覆盖了this本来的值。

## 为何使用this
```javascript
function identify() {
  return this.name.toUpperCase();
}
function speak() {
  var greeting="Hello,I`m"+identify.call(this);
  console.log(greeting);
}
var me={
	name:'Kyle'
}
var you={
	name:'Reader'
}
identify.call(me);
identify.call(you);

speak.call(me);
speak.call(you);
```
这段代码可以在不同的上下文对象(me 和 you)中复用函数identify()和speak()
,不用针对每个对象编写不同版本的函数。

如果不使用this，那就需要给identify()和speak()显式传入一个上下文对象。
```javascript
function identify(context) {
  return context.name.toUpperCase();
}
function speak(context) {
  var greeting="Hello,I`m"+identify(context);
  console.log(greeting);
}
var me={
	name:'Kyle'
}
var you={
	name:'Reader'
}
identify(you);
speak(me)
```
然而，this提供了一种更优雅的方式隐式地“传递”一个对象引用，因此可以将
API设计得更加简洁并且易于复用。

## 答案

1.
```javascript
//KYLE 
//READER 
//Hello,I`m KYLE 
//Hello,I`m Reader
```
2 . 
```javascript
//READER
//Hello,I`m KYLE
```
 
