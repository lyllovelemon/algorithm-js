# ES6+

## 声明
### 块作用域声明
JavaScript中变量作用域的基本单元是function，如果需要创建一个块作用域，除了函数声明外，还有一个简单的方式就是创建
立即执行函数(IIFE)
```javascript
var a=2;
(function IIFE() {
  var a=3;
  console.log(a);//3
})()
console.log(a);//2
```

### let声明
我们只需要{}就可以创建一个作用域。不像var声明一样变量总属于全局作用域，let声明属于块级作用域。
```javascript
var a=2;
{
	let a=3;
	console.log(a);//3
}
console.log(a);//2
```

var只声明不赋值不会报错，let只声明不赋值会报错
```javascript
{
	console.log(a);
	console.log(b);
	var a;
	let b;
}
```
> 过早访问let定义的变量叫临时性死区-你访问了一个已声明但未赋值的let变量。建议把let声明放在作用域最前面，避免临时性死区。

let在for循环的表现和var在for循环的表现不同.
 ```javascript
var func=[];
for(let i=0;i<5;i++){
	func.push(function() {
	  console.log(i);
	})
}
func[3]();//3
```
for循环头部的let i不只为for循环本身声明了一个i，而是为循环的每一次迭代都声明了一个新的i。这意味着loop
迭代内部创建的闭包封闭的每次迭代的变量。

````javascript
var func=[];
for(var i=0;i<5;i++){
	func.push(function() {
	  console.log(i);
	})
}
func[3]();//5
````
如果试验同样的代码，只把 var i 放在 for 循环头部，得到的结果就会是 5 而不是 3，因
为在外层作用域中只有一个 i，这个 i 被封闭进去，而不是每个迭代的函数会封闭一个
新的 i
### const声明
const可用于创建块作用域，const创建的是一个常量。(一旦赋值就只读的变量)
```javascript
{
	const a=2;
	console.log(a);//2
	a=3;//TypeError
}
```
常量一旦赋值就不可变，否则报错。如果需要声明一个值为undefined的常量，就要声明const a=undefined.

常量不是对这个值本身的限制，而是对赋值的那个变量的限制。这个值并没有因为const被锁定或不可变，只是赋值
本身不可变.如果这个值是复杂值,比如对象或数组,其内容是可变的.
```javascript
{
	const a=[1,2,3];
	a.push(4);
	console.log(a);//[1,2,3.4]
	a=42;//TypeError
}
```
变量a并不持有一个常量数组,而是持有一个指向数组的常量引用,数组本身是可变的。

### 块作用域函数
从ES6开始，块内声明的函数，其作用域在这个块内。
```javascript
{
	foo()
	function foo() {
	  
	}
}
foo();//ReferenceError
```
foo()函数声明在{}块内部，ES6支持块级作用域，所以在块外不可用.需要注意它在块内提升了.

## spread/rest
ES6引入了一个新的运算符... ,通常称为spread/rest(展开或收集)运算符.
```javascript
function foo(x,y,z) {
  console.log(x,y,z)
}
foo(...[1,2,3])//1 2 3
```
当...作用于数组,它会把数组展开为每一项的值.

...可以代替apply()
```javascript
foo.apply(null,[1,2,3]);//1 2 3

var a=[2,3,4];
var b=[1,...a,5];
console.log(b);//[1,2,3,4,5] 
```
在这种用法中,...等价于concat(),[1].concat(a,[5]);

...的另外一种用法,它可以把一系列值收集到一起成为一个数组.
```javascript
function foo(x,y,...z) {
  console.log(x,y,z)
}
foo(1,2,3,4,5);// 1 2 [3,4,5]
```

## 答案
### let作用域
1.
```javascript
//undefined
//ReferenceError
```