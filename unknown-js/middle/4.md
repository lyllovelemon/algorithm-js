# 强制类型转换
## 值类型转换
将值从一种类型转换成另一种类型被称为类型转换，这是显式的。
隐式的类型转换称为强制类型转换。
> 类型转换发生于静态类型语言的编译阶段，强制类型转换发生在动态类型语言的运行时。
```javascript
let a=42;
let b=a+"";//隐式强制类型转换
let c=new String(a);//显式强制类型转换
```
## 类型转换规则

### toString()
负责处理非字符串到字符串的强制类型转换。

转换规则如下：
1. null转为"null",undefined转为"undefined",true转换为"true"
2. 数字的转换遵循通用规则,极小和极大数使用指数形式。
3. 普通对象,toString()返回内部属性[[class]]的值，如"[Object Object]";如果对象有自己的toString()方法，字符串转换时就会调用该方法并使用其返回值。
4. 数组调用toString(),将所有单元字符串化以后用","连接起来。
```javascript
let a=1.07*1000*1000*1000*1000*1000*1000*1000;
a.toString();//"1.07e21"
let b=[1,2,3];
b.toString();//"1,2,3"
```
### JSON()
对大多数简单值来说，JSON 字符串化和 toString() 的效果基本相同，只不过序列化的结
果总是字符串。
```javascript
JSON.stringify(42);//"42"
JSON.stringify("42");//"42"
JSON.stringify(null);//"null"
JSON.stringify(true);//"true"
```
所有安全的JSON值都可以用JSON()字符串序列化。
不安全的JSON：
+ undefined
+ 包含循环引用的obejct
+ function
+ symbol

在遇到不安全的JSON值时，JSON。stringfy()会自动忽略它们，在数组中则会返回null。
```javascript
JSON.stringify(undefined);//undefined
JSON.stringify(function() {})//undefined
JSON.stringify([1,undefined,function() {},4]);//"[1,null,null,4]"
JSON.stringify({a:2,b:function() {}});//"{"a":2}"
```

> JSON()并非严格意义上的强制类型转换。

## ToNumber
非数字值转换为数字值
规则：
+ true转换为1，false转换为0
+ undefined转换为NaN,null转换为0
+ 对象会被强制转换为基本类型值，如果返回的是非数字类型的值，再将它
转为数字类型值

对象转换为基本类型值,抽象操作toPrimitive会首先检查该值是否
有valueOf()方法。如果有并且返回基本类型值，
就使用该值进行强制类型转换。如果没有就使用toString()的返回值
进行强制类型转换。

如果valueOf()和toString()没有返回基本类型值，就会报typeError错误。

## toBoolean
JavaScript中的值可以分为以下两类:
1. 可以被强制转换为false的值
2. 其他（被强制转换为true的值）

### 假值
以下这些值是假值:
+ undefined
+ null
+ false
+ +0 、-0、NaN
+ ""
假值的布尔强制类型转换值为false。
假值列表以外的值是真值。

### 假值对象

```javascript
let a={
	valueOf() {
	  return '42';
	}
};
let b={
	toString(){
		return '42';
	}
}
let c=[4,2];
c.toString=function() {
  return this.join("");
};
Number(a);
Number(b);
Number(c);
Number("");
Number([]);
Number(["abc"]);
```
### 真值
真值就是假值列表以外的值
```
let a="false";
let b="0";
let c="";
let d=Boolean(a &&b &&c);
console.log(d);
```
所有字符串都是真值，""除外。因为它是假值列表中唯一的字符串。

```
let a=[];
let b={};
let c=function(){};
let d=Boolean(a && b && c);
```
[],{},function(){}都不在假值列表里，因此它们都是真值。

## 显式强制类型转换
1. 字符串和数字之间的转换
String()，Number()两个内建函数用于字符串和数字之间的转换。
> 注意：它们没有new关键字，并不创建封装对象。
```
let a=42;
let b=String(a);
let c="3.14";
let d=Number(c);
console.log(b);
console.log(d);
```

除了String()，Number(),还有其他方法可以用于数字和字符串的显式转换
```
let a=42;
let b=a.toString();

let c="3.14";
let d=+c;
console.log(b);
console.log(d);
```
toString()对42这样的基本类型不适用，因此JavaScript引擎会为42创建一个封装对象，然后对该对象调用toString()。
+运算符显式将c转换为数字。

```
let a="3.14";
let b=5++a;
console.log(b);
```
由于--会被当作递减运算符，所以不能用它撤销反转，而应该用- -"3.14"这样，在中间加一个空格，才能得到正确结果3.14.

```
console.log(1+-+++-+1);
```
上面这个例子非常糟糕，尽量不要把一元运算符+/-和其他运算符放在一起使用。

### +运算符
一元运算符+的一个常见用途是将日期对象(Date)对象强制类型转换成数字，返回结果为以微秒为单位的时间戳(13位).
```
let d=new Date(""Mon, 18 Aug 2014 08:53:06 CDT");
+d;// 1408369986000
```
我们常用下面的方法获得当前的时间戳
```
let timestamp=+new Date();
```
> 上面的代码还可以写成let timestamp=+new Date,因为构造函数没有参数时可以不带().

除了上面的方法,使用更加显式的方法会更好一些.
```
let timestamp=new Date().getTime();
//or
let timestamp=Date.now();
```
### ~运算符
~运算符(字位操作"非")和一些特殊数字一起使用时会产生类似强制类型转换的效果,返回另外一个数字.
```	
0 | -0; // 0
0 | NaN; // 0
0 | Infinity; // 0
0 | -Infinity; // 0
```
~首先将值强制类型转换为32位数字,然后执行字位操作"非"(对每一个字位进行反转).
```
~42;
```
~x大致返回-(x+1),在-(x+1)中唯一得到0的值是-1.x为-1时,~和一些数字值在一起会返回假值0,其余情况全都返回真值.

indexOf()执行这一规则,该方法在字符串中搜索指定的子字符串，如果找到就返回子字符串所在的位置（从 0 开始），否则返回 -1.
```
let a="Hello world";
if(a.indexOf("lo")>=0){//true

}
~a.indexOf("lo");//-4
```
### 字位截除
~~可以用于截除数字值的小数部分.~~中的第一个~执行toInt32并反转字位,然后第二个~再进行一次字位反转回原值,最后得到的是toInt32的结果.
> 注意:~~只适用于32位数字
```
Math.floor(-49.6);
~~49.6
```

## 答案
### 假值对象
1. 
//42
//42
//42
//0
//0
//NaN
### 真值
1. //true
2. //true

## 显式强制类型转换
1. //"42"
//3.14

2. //"42"
//3.14
3. //8.14
4. //2
### ~运算符
1. //-43
### 字位截除
1. //-50
//-49