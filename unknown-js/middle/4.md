# 强制类型转换
## 值类型转换
将值从一种类型转换成另一种类型被称为类型转换，这是显式的。
隐式的类型转换称为强制类型转换。
> 类型转换发生于静态类型语言的编译阶段，强制类型转换发生在动态类型语言的运行时。
```javascript
let a=42;
let b=a+"";//隐式强制类型转换
let c=new String(a);//显式强制类型转换
```
## 类型转换规则

### toString()
负责处理非字符串到字符串的强制类型转换。

转换规则如下：
1. null转为"null",undefined转为"undefined",true转换为"true"
2. 数字的转换遵循通用规则,极小和极大数使用指数形式。
3. 普通对象,toString()返回内部属性[[class]]的值，如"[Object Object]";如果对象有自己的toString()方法，字符串转换时就会调用该方法并使用其返回值。
4. 数组调用toString(),将所有单元字符串化以后用","连接起来。
```javascript
let a=1.07*1000*1000*1000*1000*1000*1000*1000;
a.toString();//"1.07e21"
let b=[1,2,3];
b.toString();//"1,2,3"
```
### JSON()
对大多数简单值来说，JSON 字符串化和 toString() 的效果基本相同，只不过序列化的结
果总是字符串。
```javascript
JSON.stringify(42);//"42"
JSON.stringify("42");//"42"
JSON.stringify(null);//"null"
JSON.stringify(true);//"true"
```
所有安全的JSON值都可以用JSON()字符串序列化。
不安全的JSON：
+ undefined
+ 包含循环引用的obejct
+ function
+ symbol

在遇到不安全的JSON值时，JSON。stringfy()会自动忽略它们，在数组中则会返回null。
```javascript
JSON.stringify(undefined);//undefined
JSON.stringify(function() {})//undefined
JSON.stringify([1,undefined,function() {},4]);//"[1,null,null,4]"
JSON.stringify({a:2,b:function() {}});//"{"a":2}"
```

> JSON()并非严格意义上的强制类型转换。

## ToNumber
非数字值转换为数字值
规则：
+ true转换为1，false转换为0
+ undefined转换为NaN,null转换为0
+ 对象会被强制转换为基本类型值，如果返回的是非数字类型的值，再将它
转为数字类型值

对象转换为基本类型值,抽象操作toPrimitive会首先检查该值是否
有valueOf()方法。如果有并且返回基本类型值，
就使用该值进行强制类型转换。如果没有就使用toString()的返回值
进行强制类型转换。

如果valueOf()和toString()没有返回基本类型值，就会报typeError错误。

## toBoolean
JavaScript中的值可以分为以下两类:
1. 可以被强制转换为false的值
2. 其他（被强制转换为true的值）

### 假值
以下这些值是假值:
+ undefined
+ null
+ false
+ +0 、-0、NaN
+ ""
假值的布尔强制类型转换值为false。
假值列表以外的值是真值。

### 假值对象

```javascript
let a={
	valueOf() {
	  return '42';
	}
};
let b={
	toString(){
		return '42';
	}
}
let c=[4,2];
c.toString=function() {
  return this.join("");
};
Number(a);
Number(b);
Number(c);
Number("");
Number([]);
Number(["abc"]);
```
## 答案
### toNumber
1. 
//42
//42
//42
//0
//0
//NaN